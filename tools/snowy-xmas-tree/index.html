<!doctype html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>白昼雪地 3D 圣诞树 · 昼夜切换</title>
  <style>
    :root {
      --bg-top: #cfe6ff;
      --bg-bottom: #f8fbff;
      --text: #2d3a4f;
      --panel: rgba(255, 255, 255, 0.7);
      --panel-border: rgba(255, 255, 255, 0.4);
    }

    body {
      margin: 0;
      overflow: hidden;
      font-family: "Inter", "PingFang SC", "Microsoft YaHei", sans-serif;
      background: linear-gradient(180deg, var(--bg-top), var(--bg-bottom));
      transition: background 0.8s ease;
      color: var(--text);
    }

    body.night {
      --bg-top: #0f2244;
      --bg-bottom: #0a1326;
      --text: #dbe7ff;
      --panel: rgba(10, 19, 38, 0.8);
      --panel-border: rgba(219, 231, 255, 0.25);
    }

    #ui {
      position: fixed;
      top: 16px;
      right: 16px;
      z-index: 10;
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      padding: 12px 14px;
      backdrop-filter: blur(8px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
      transition: background 0.6s ease, color 0.6s ease, border 0.6s ease;
    }

    #toggle {
      background: linear-gradient(120deg, #a9cfff, #d7c6ff);
      border: none;
      color: #0f1a2b;
      padding: 10px 14px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 6px 14px rgba(0, 0, 0, 0.1);
      transition: transform 0.2s ease, box-shadow 0.3s ease;
    }

    #toggle:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.18);
    }

    #caption {
      margin-top: 8px;
      font-size: 13px;
      line-height: 1.6;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <div id="ui">
    <button id="toggle">切换到夜晚</button>
    <div id="caption">冬日雪地里的圣诞树，支持昼夜切换。飘落的雪花落地后会被轻轻融化。</div>
  </div>
  <div id="scene"></div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';

    const container = document.getElementById('scene');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(6, 5.5, 10);

    scene.fog = new THREE.FogExp2(0xeaf4ff, 0.045);

    const clock = new THREE.Clock();

    const hemiLight = new THREE.HemisphereLight(0xddeeff, 0xffffff, 1.0);
    hemiLight.position.set(0, 8, 0);
    scene.add(hemiLight);

    const sunLight = new THREE.DirectionalLight(0xffffff, 1.1);
    sunLight.position.set(5, 10, 4);
    sunLight.castShadow = true;
    scene.add(sunLight);

    const moonLight = new THREE.PointLight(0x8fb3ff, 0.0, 35, 2);
    moonLight.position.set(-6, 8, 3);
    scene.add(moonLight);

    const accentLight = new THREE.PointLight(0xffd6a6, 0.0, 25, 2.2);
    accentLight.position.set(5, 6, -4);
    scene.add(accentLight);

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const groundGeo = new THREE.CircleGeometry(16, 120);
    const groundMat = new THREE.MeshStandardMaterial({
      color: new THREE.Color('#f7fbff'),
      roughness: 0.85,
      metalness: 0.02
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.receiveShadow = true;
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    function createSnowTexture() {
      const size = 128;
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext('2d');
      const grd = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
      grd.addColorStop(0, 'rgba(255,255,255,0.95)');
      grd.addColorStop(0.3, 'rgba(255,255,255,0.9)');
      grd.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, size, size);
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      return texture;
    }

    const snowTexture = createSnowTexture();
    const snowflakes = [];
    const snowBounds = { x: 14, y: 12, z: 14 };

    function spawnSnowflake() {
      const material = new THREE.SpriteMaterial({
        map: snowTexture,
        transparent: true,
        opacity: 0.85,
        depthWrite: false
      });
      const sprite = new THREE.Sprite(material);
      sprite.position.set(
        (Math.random() - 0.5) * snowBounds.x,
        Math.random() * snowBounds.y + 2,
        (Math.random() - 0.5) * snowBounds.z
      );
      const s = Math.random() * 0.28 + 0.18;
      sprite.scale.set(s, s, s);
      sprite.userData = {
        speed: Math.random() * 0.8 + 0.4,
        drift: (Math.random() - 0.5) * 0.15,
        fade: Math.random() * 0.4,
      };
      sprite.renderOrder = 1;
      scene.add(sprite);
      snowflakes.push(sprite);
    }

    for (let i = 0; i < 160; i++) {
      spawnSnowflake();
    }

    const tree = new THREE.Group();
    scene.add(tree);

    const trunkMat = new THREE.MeshStandardMaterial({
      color: '#5c3a2c',
      roughness: 0.9,
    });
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.5, 1.2, 12), trunkMat);
    trunk.castShadow = true;
    trunk.position.y = 0.6;
    tree.add(trunk);

    const branchMaterial = new THREE.MeshStandardMaterial({
      color: '#6fa481',
      emissive: '#cce7d5',
      emissiveIntensity: 0.08,
      roughness: 0.7,
    });

    const tiers = 4;
    for (let i = 0; i < tiers; i++) {
      const height = 1.3 - i * 0.1;
      const radius = 2.0 - i * 0.35;
      const cone = new THREE.Mesh(
        new THREE.ConeGeometry(radius, height, 32, 1, false),
        branchMaterial.clone()
      );
      cone.material.emissiveIntensity = 0.05 + i * 0.02;
      cone.position.y = 0.8 + i * 0.7;
      cone.castShadow = true;
      tree.add(cone);

      const snowCap = new THREE.Mesh(
        new THREE.ConeGeometry(radius * 0.9, height * 0.55, 32),
        new THREE.MeshStandardMaterial({
          color: '#edf4ff',
          roughness: 0.4,
          metalness: 0.0
        })
      );
      snowCap.position.set(0, cone.position.y + height * 0.28, 0);
      snowCap.castShadow = false;
      tree.add(snowCap);
    }

    const featherMat = new THREE.MeshStandardMaterial({
      color: '#caa8ff',
      emissive: '#b58cff',
      emissiveIntensity: 0.25,
      transparent: true,
      opacity: 0.65,
      side: THREE.DoubleSide,
      roughness: 0.5,
    });
    const featherGeo = new THREE.PlaneGeometry(0.35, 0.9, 6, 2);
    for (let i = 0; i < 32; i++) {
      const feather = new THREE.Mesh(featherGeo, featherMat.clone());
      const angle = Math.random() * Math.PI * 2;
      const radius = 0.3 + Math.random() * 1.5;
      const y = 1.0 + Math.random() * 2.0;
      feather.position.set(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
      feather.rotation.set(Math.random() * 0.6, angle, Math.random() * 0.6);
      tree.add(feather);
    }

    const ornamentGroup = new THREE.Group();
    tree.add(ornamentGroup);

    const crystalMat = new THREE.MeshStandardMaterial({
      color: '#b9d7ff',
      emissive: '#d8e9ff',
      emissiveIntensity: 0.35,
      metalness: 0.2,
      roughness: 0.2,
      transparent: true,
      opacity: 0.9
    });
    for (let i = 0; i < 28; i++) {
      const crystal = new THREE.Mesh(new THREE.OctahedronGeometry(0.18), crystalMat.clone());
      const angle = Math.random() * Math.PI * 2;
      const radius = 0.6 + Math.random() * 1.6;
      const y = 1.1 + Math.random() * 2.1;
      crystal.position.set(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
      crystal.castShadow = true;
      ornamentGroup.add(crystal);
    }

    const bellMat = new THREE.MeshStandardMaterial({
      color: '#e9edf3',
      metalness: 0.65,
      roughness: 0.18,
      emissive: '#f0f4ff',
      emissiveIntensity: 0.2
    });
    for (let i = 0; i < 18; i++) {
      const bell = new THREE.Mesh(new THREE.SphereGeometry(0.16, 18, 12), bellMat.clone());
      const angle = Math.random() * Math.PI * 2;
      const radius = 0.7 + Math.random() * 1.3;
      const y = 0.9 + Math.random() * 1.8;
      bell.position.set(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
      bell.castShadow = true;
      ornamentGroup.add(bell);
    }

    const starShape = new THREE.Shape();
    const outer = 0.55, inner = 0.24;
    for (let i = 0; i < 5; i++) {
      const a = (i * 72 - 90) * Math.PI / 180;
      const ax = Math.cos(a) * outer, ay = Math.sin(a) * outer;
      const b = ((i + 0.5) * 72 - 90) * Math.PI / 180;
      const bx = Math.cos(b) * inner, by = Math.sin(b) * inner;
      if (i === 0) starShape.moveTo(ax, ay); else starShape.lineTo(ax, ay);
      starShape.lineTo(bx, by);
    }
    starShape.closePath();
    const star = new THREE.Mesh(
      new THREE.ExtrudeGeometry(starShape, { depth: 0.25, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.05 }),
      new THREE.MeshStandardMaterial({
        color: '#f7d67a',
        emissive: '#ffe9a3',
        emissiveIntensity: 0.8,
        metalness: 0.5,
        roughness: 0.3
      })
    );
    star.position.set(0, 3.25, 0);
    star.rotation.y = Math.PI / 10;
    star.castShadow = true;
    tree.add(star);

    const giftGroup = new THREE.Group();
    scene.add(giftGroup);
    const giftColors = [
      ['#d8c8ff', '#b49bff'],
      ['#b9d8ff', '#8fb5ff'],
      ['#f2e6b8', '#d9c78c'],
      ['#cce6ff', '#9fc8f7'],
    ];

    function addGift(pos, baseColor, ribbon) {
      const gift = new THREE.Group();
      const box = new THREE.Mesh(new THREE.BoxGeometry(1, 0.7, 1), new THREE.MeshStandardMaterial({
        color: baseColor,
        roughness: 0.55,
        metalness: 0.1
      }));
      box.position.y = 0.35;
      box.castShadow = true;
      gift.add(box);

      const ribbonGeo = new THREE.BoxGeometry(1.02, 0.1, 0.18);
      const ribbonMat = new THREE.MeshStandardMaterial({ color: ribbon, metalness: 0.2, roughness: 0.4 });
      const ribbonX = new THREE.Mesh(ribbonGeo, ribbonMat);
      ribbonX.position.y = 0.72;
      const ribbonZ = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.1, 1.02), ribbonMat);
      ribbonZ.position.y = 0.72;
      const knot = new THREE.Mesh(new THREE.SphereGeometry(0.08, 12, 12), ribbonMat);
      knot.position.y = 0.78;
      gift.add(ribbonX, ribbonZ, knot);

      gift.position.copy(pos);
      giftGroup.add(gift);
    }

    addGift(new THREE.Vector3(1.6, 0, 1.2), giftColors[0][0], giftColors[0][1]);
    addGift(new THREE.Vector3(-1.3, 0, 1.0), giftColors[1][0], giftColors[1][1]);
    addGift(new THREE.Vector3(1.0, 0, -1.6), giftColors[2][0], giftColors[2][1]);
    addGift(new THREE.Vector3(-0.3, 0, -1.1), giftColors[3][0], giftColors[3][1]);

    const controls = {
      mode: 'day',
    };

    function setMode(mode) {
      controls.mode = mode;
      const isNight = mode === 'night';
      document.body.classList.toggle('night', isNight);
      document.getElementById('toggle').textContent = isNight ? '切换到白天' : '切换到夜晚';
      scene.fog.color.set(isNight ? '#0c1d36' : '#eaf4ff');
      scene.fog.density = isNight ? 0.06 : 0.045;
      hemiLight.intensity = isNight ? 0.4 : 1.0;
      sunLight.intensity = isNight ? 0.18 : 1.1;
      sunLight.color.set(isNight ? '#7ca0ff' : '#ffffff');
      moonLight.intensity = isNight ? 1.15 : 0.0;
      accentLight.intensity = isNight ? 0.8 : 0.0;
      ornamentGroup.children.forEach((obj, idx) => {
        if (obj.material && obj.material.emissive) {
          obj.material.emissiveIntensity = isNight ? 0.45 + (idx % 5) * 0.05 : 0.2;
        }
      });
      tree.children.forEach(obj => {
        if (obj.material && obj.material.emissive) {
          obj.material.emissiveIntensity = isNight ? 0.25 : 0.1;
        }
      });
    }

    document.getElementById('toggle').addEventListener('click', () => {
      setMode(controls.mode === 'day' ? 'night' : 'day');
    });

    function updateSnow(delta) {
      snowflakes.forEach((flake, idx) => {
        const data = flake.userData;
        flake.position.y -= data.speed * delta * 2.2;
        flake.position.x += data.drift * delta * 1.4;
        flake.position.z += Math.sin(clock.elapsedTime * 0.8 + idx) * 0.002;
        if (flake.position.y < 0.2) {
          flake.scale.multiplyScalar(0.96);
          flake.material.opacity *= 0.86;
        }
        if (flake.material.opacity < 0.08 || flake.scale.x < 0.05) {
          flake.position.set(
            (Math.random() - 0.5) * snowBounds.x,
            snowBounds.y,
            (Math.random() - 0.5) * snowBounds.z
          );
          const s = Math.random() * 0.28 + 0.18;
          flake.scale.set(s, s, s);
          flake.material.opacity = 0.9 + data.fade * 0.1;
        }
      });
    }

    function animate() {
      const delta = clock.getDelta();
      tree.rotation.y += delta * 0.12;
      updateSnow(delta);
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    setMode('day');
    animate();
  </script>
</body>

</html>
